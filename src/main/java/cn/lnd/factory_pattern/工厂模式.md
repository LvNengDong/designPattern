## 工厂模式

**没事不要用工厂模式创建对象**



工厂模式有三种更为精细的分类，分别是：

- **简单工厂**
- **工厂方法**
- **抽象工厂**（不常用）



重点：

- 哪些场景下应该使用工厂模式？
- 相较于直接使用 new 来创建对象，使用工厂模式有何优点？



## Simple Factory（简单工厂）

**什么是简单工厂模式？**

### Base

```java
package cn.lnd.factory_pattern.simple_factory;

/**
 * @Author lnd
 * @Description 简单工厂模式Case
 * @Date 2022/7/23 10:32
 */
public class RuleConfigSource {

    public RuleConfig load(String ruleConfigFilePath) {

        // 获取文件名后缀
        String ruleConfigExtension = getFileExtension(ruleConfigFilePath);

        // 根据文件名后缀，创建不同的解析器
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(ruleConfigExtension)) {
            parser = new JsonRuleConfigparser();
        } else if ("xml".equalsIgnoreCase(ruleConfigExtension)) {
            parser = new XmlRuleConfigparser();
        } else if ("yaml".equalsIgnoreCase(ruleConfigExtension)) {
            parser = new YamlRuleConfigparser();
        } else if ("properties".equalsIgnoreCase(ruleConfigExtension)) {
            parser = new PropertiesRuleConfigparser();
        } else {
            throw new InvalidRuleConfigException("Rule config file format is not supported：" + ruleConfigFilePath);
        }

        String configText = "This is a config info context"; // 模拟从文件中读到的数据
        // 使用解析器，将存储在文件中的配置解析成内存对象RuleConfig
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }

    /**
     * 解析文件名获取扩展名
     * For Example：rule.josn -> json
     *
     * @param ruleConfigFilePath 文件名名
     * @return 文件名后缀
     */
    private String getFileExtension(String ruleConfigFilePath) {
        // TODO
        return "json";
    }
}
```





为了让代码的逻辑更加清晰，可读性更好，我们可以将功能独立的代码块封装成函数。比如：将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。具体代码如下：

```java
package cn.lnd.factory_pattern.simple_factory;

/**
 * @Author lnd
 * @Description 简单工厂模式Case
 * @Date 2022/7/23 10:32
 */
public class RuleConfigSourceV2 {

    public RuleConfig load(String ruleConfigFilePath) {

        // 获取文件名后缀
        String ruleConfigExtension = getFileExtension(ruleConfigFilePath);

        // 根据文件名后缀，创建不同的解析器
        IRuleConfigParser parser = createParser(ruleConfigExtension);
        if (parser == null) {
            throw new InvalidRuleConfigException("Rule config file format is not supported：" + ruleConfigFilePath);
        }

        String configText = "This is a config info context"; // 模拟从文件中读到的数据
        // 使用解析器，将存储在文件中的配置解析成内存对象RuleConfig
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }

    /**
     * 根据文件名后缀，创建不同的解析器
     *
     * @param configFormat 文件名后缀
     * @return
     */
    private IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
            parser = new JsonRuleConfigparser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
            parser = new XmlRuleConfigparser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
            parser = new YamlRuleConfigparser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
            parser = new PropertiesRuleConfigparser();
        }
        return parser;
    }

    /**
     * 解析文件名获取扩展名
     * For Example：rule.josn -> json
     *
     * @param ruleConfigFilePath 文件名名
     * @return 文件名后缀
     */
    private String getFileExtension(String ruleConfigFilePath) {
        // TODO
        return "json";
    }
}
```





为了让类的职责更加单一，我们还可以进一步将 createParser() 函数抽离到一个单独的类中，让这个类只负责对象的创建。这个类就是所谓的『简单工厂模式』中的工厂类。具体代码如下：

```java
package cn.lnd.factory_pattern.simple_factory;

/**
 * @Author lnd
 * @Description 简单工厂模式Case
 * @Date 2022/7/23 10:32
 */
public class RuleConfigSourceV3 {

    public RuleConfig load(String ruleConfigFilePath) {

        // 获取文件名后缀
        String ruleConfigExtension = getFileExtension(ruleConfigFilePath);

        // 根据文件名后缀，创建不同的解析器
        IRuleConfigParser parser = RuleConfigParseFactory.createParser(ruleConfigExtension);
        if (parser == null) {
            throw new InvalidRuleConfigException("Rule config file format is not supported：" + ruleConfigFilePath);
        }

        String configText = "This is a config info context"; // 模拟从文件中读到的数据
        // 使用解析器，将存储在文件中的配置解析成内存对象RuleConfig
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }



    /**
     * 解析文件名获取扩展名
     * For Example：rule.josn -> json
     *
     * @param ruleConfigFilePath 文件名名
     * @return 文件名后缀
     */
    private String getFileExtension(String ruleConfigFilePath) {
        // TODO
        return "json";
    }
}
```

```java
package cn.lnd.factory_pattern.simple_factory;

/**
 * @Author lnd
 * @Description 工厂类
 * @Date 2022/7/23 11:30
 */
public class RuleConfigParseFactory {

    /**
     * 根据文件名后缀，创建不同的解析器
     *
     * @param configFormat 文件名后缀
     * @return
     */
    public static IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
            parser = new JsonRuleConfigparser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
            parser = new XmlRuleConfigparser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
            parser = new YamlRuleConfigparser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
            parser = new PropertiesRuleConfigparser();
        }
        return parser;
    }
}
```



### Tip

- 大部分的工厂类都是以单词 “Factory” 结尾的，但这不是绝对的，比如 Java 中的 DateFormat、Calender。
- 工厂类中创建对象的方法一般都是 createXxx()，但有的也命名为 getInstance()、newInstance() 等，甚至有的命名为 valueOf()，比如 Java 中 String 类的 valueOf() 方法。这个都是由具体的应用场景和开发人员的习惯决定的。



### Optimization

在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都会创建一个新的 parser。实际上，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 的时候，我们从缓存中直接取出 parser 对象使用。这就类似于是一个`『简单工厂模式+单例模式』`的结合。具体代码如下：

```java
package cn.lnd.factory_pattern.simple_factory;

import java.util.HashMap;
import java.util.Map;

/**
 * @Author lnd
 * @Description 简单工厂模式+单例模式
 * @Date 2022/7/23 11:30
 */
public class RuleConfigParseFactoryV2 {

    private static final Map<String, IRuleConfigParser> cachedParsers = new HashMap<>();
    
    static {
        cachedParsers.put("json", new JsonRuleConfigparser());
        cachedParsers.put("xml", new XmlRuleConfigparser());
        cachedParsers.put("yaml", new YamlRuleConfigparser());
        cachedParsers.put("properties", new PropertiesRuleConfigparser());
    }
    
    /**
     * 根据文件名后缀，创建不同的解析器
     *
     * @param configFormat 文件名后缀
     * @return
     */
    public static IRuleConfigParser createParser(String configFormat) {
        if (configFormat == null || configFormat.isEmpty()){
            throw new IllegalArgumentException();
        }
        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
        return parser;
    }
}
```



### Explain

对于上面两种简单工厂模式的实现逻辑，如果我们要添加新的 parser，那势必要改动 RuleConfigParserFactory 中的代码，可以说这违背了`『开闭原则』`。但我们要以辩证的眼光看待问题，不要太过教条主义，只要不是频繁地添加 parser，只是偶尔修改一下 RuleConfigParserFactory 中的代码，稍微不符合开闭原则，也是完全可以接受的。

除此之外，在第一版的 RuleConfigParserFactory 中，有一组 if 分支判断，这其实也是可以用多态或设计模式来进行优化的。但同样，如果代码中 if 分支不是很多，存在 if 也是完全可以接受的。用多态或设计模式来代替 if 分支判断逻辑，虽然提高了代码的可扩展性，但也增加了类的个数，牺牲了代码的可读性。

对于这些情况，都是需要开发人员来主观判断衡量的。







------

## Factory Method（工厂方法）

### Base

```java
package cn.lnd.factory_pattern.factory_method;
import cn.lnd.factory_pattern.simple_factory.IRuleConfigParser;

/**
 * @Author lnd
 * @Description
 * @Date 2022/7/23 12:11
 */
public interface IRuleConfigParserFactory {
    /**
     * 创建 RuleConfigParser 实例对象
     *
     * @return
     */
    IRuleConfigParser createParser();
}


public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory{
    private static final JsonRuleConfigparser jsonRuleConfigparser = new JsonRuleConfigparser();

    @Override
    public IRuleConfigParser createParser() {
        return jsonRuleConfigparser;
    }
}


public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory{
    private static final PropertiesRuleConfigparser propertiesRuleConfigparser = new PropertiesRuleConfigparser();

    @Override
    public IRuleConfigParser createParser() {
        return propertiesRuleConfigparser;
    }
}

public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory{
    private static final XmlRuleConfigparser xmlRuleConfigparser = new XmlRuleConfigparser();

    @Override
    public IRuleConfigParser createParser() {
        return xmlRuleConfigparser;
    }
}


public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory{
    private static final YamlRuleConfigparser yamlRuleConfigparser = new YamlRuleConfigparser();

    @Override
    public IRuleConfigParser createParser() {
        return yamlRuleConfigparser;
    }
}
```

```java
public class MainApp {
    public static void main(String[] args) {
        IRuleConfigParserFactory factory = new JsonRuleConfigParserFactory();
        // 多态
        factory.createParser();
    }
}
```

实际上，这就是工厂方法模式的典型实现。当我们新增一种 parser 的时候，只要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，**工厂方法模式比简单工厂模式更加符合开闭原则**。



### Question

这样看起来工厂方法模式的设计要比简单工厂好得多，但实际上，这种工厂方法模式最大的问题在于这些工厂类的使用上。比如下面这段代码：

```java
package cn.lnd.factory_pattern.factory_method;


import cn.lnd.factory_pattern.simple_factory.IRuleConfigParser;
import cn.lnd.factory_pattern.simple_factory.InvalidRuleConfigException;
import cn.lnd.factory_pattern.simple_factory.RuleConfig;

/**
 * @Author lnd
 * @Description
 * @Date 2022/7/23 12:31
 */
public class RuleConfigSource {

    public RuleConfig load(String ruleConfigFilePath) {

        // 获取文件名后缀
        String ruleConfigExtension = getFileExtension(ruleConfigFilePath);

        // 根据文件名后缀，创建不同的解析器
        IRuleConfigParserFactory factory = null;
        if ("json".equalsIgnoreCase(ruleConfigExtension)) {
            factory = new JsonRuleConfigParserFactory();
        } else if ("xml".equalsIgnoreCase(ruleConfigExtension)) {
            factory = new XmlRuleConfigParserFactory();
        } else if ("yaml".equalsIgnoreCase(ruleConfigExtension)) {
            factory = new YamlRuleConfigParserFactory();
        } else if ("properties".equalsIgnoreCase(ruleConfigExtension)) {
            factory = new PropertiesRuleConfigParserFactory();
        } else {
            throw new InvalidRuleConfigException("Rule config file format is not supported：" + ruleConfigFilePath);
        }
        
        IRuleConfigParser parser = factory.createParser();
        
        String configText = "This is a config info context"; // 模拟从文件中读到的数据
        // 使用解析器，将存储在文件中的配置解析成内存对象RuleConfig
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
    

    /**
     * 解析文件名获取扩展名
     * For Example：rule.josn -> json
     *
     * @param ruleConfigFilePath 文件名名
     * @return 文件名后缀
     */
    private String getFileExtension(String ruleConfigFilePath) {
        // TODO
        return "json";
    }
}
```

从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初版本的代码非常相似。引入『工厂方法』反倒让设计变得更加复杂了，那怎么来解决这个问题呢？

**我们可以为工厂类再创建一个工厂，就是工厂的工厂，用来创建工厂类对象**。

